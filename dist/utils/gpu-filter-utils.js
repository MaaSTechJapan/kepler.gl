"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setFilterGpuMode = setFilterGpuMode;
exports.assignGpuChannels = assignGpuChannels;
exports.assignGpuChannel = assignGpuChannel;
exports.resetFilterGpuMode = resetFilterGpuMode;
exports.getGpuFilterProps = getGpuFilterProps;
exports.getDatasetFieldIndexForFilter = getDatasetFieldIndexForFilter;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _utils = require("./utils");

var _defaultSettings = require("../constants/default-settings");

var _dataUtils = require("./data-utils");

var _moment = _interopRequireDefault(require("moment"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Set gpu mode based on current number of gpu filters exists
 * @param {Object} gpuFilter
 * @param {Array<Object>} filters
 */
function setFilterGpuMode(filter, filters) {
  // filter can be apply to multiple dataset, hence gpu filter mode should also be
  // an array, however, to keep us sane, for now, we only check if there is available channel for every dataId,
  // if all of them has, we set gpu mode to true
  // TODO: refactor filter so we don't keep an array of everything
  filter.dataId.forEach(function (dataId, datasetIdx) {
    var gpuFilters = filters.filter(function (f) {
      return f.dataId.includes(dataId) && f.gpu;
    });

    if (filter.gpu && gpuFilters.length === _defaultSettings.MAX_GPU_FILTERS) {
      return (0, _utils.set)(['gpu'], false, filter);
    }
  });
  return filter;
}

function assignGpuChannels(allFilters) {
  return allFilters.reduce(function (accu, f, index) {
    var filters = accu; // if gpu is true assign and validate gpu Channel

    if (f.gpu) {
      f = assignGpuChannel(f, accu);
      filters = (0, _utils.set)([index], f, accu);
    }

    return filters;
  }, allFilters);
}
/**
 * Assign a new gpu filter a channel based on first availability
 * @param {Object} filter
 * @param {Array<Object>} filters
 */


function assignGpuChannel(filter, filters) {
  // find first available channel
  if (!filter.gpu) {
    return filter;
  }

  var gpuChannel = filter.gpuChannel || [];
  filter.dataId.forEach(function (dataId, datasetIdx) {
    var findGpuChannel = function findGpuChannel(channel) {
      return function (f) {
        var dataIdx = (0, _utils.toArray)(f.dataId).indexOf(dataId);
        return f.id !== filter.id && dataIdx > -1 && f.gpu && (0, _utils.toArray)(f.gpuChannel)[dataIdx] === channel;
      };
    };

    if (Number.isFinite(gpuChannel[datasetIdx]) && !filters.find(findGpuChannel(gpuChannel[datasetIdx]))) {
      // if value is already assigned and valid
      return;
    }

    var i = 0;

    while (i < _defaultSettings.MAX_GPU_FILTERS) {
      if (!filters.find(findGpuChannel(i))) {
        gpuChannel[datasetIdx] = i;
        return;
      }

      i++;
    }
  }); // if cannot find channel for all dataid, set gpu back to false
  // TODO: refactor filter to handle same filter different gpu mode

  if (!gpuChannel.length || !gpuChannel.every(Number.isFinite)) {
    return _objectSpread({}, filter, {
      gpu: false
    });
  }

  return _objectSpread({}, filter, {
    gpuChannel: gpuChannel
  });
}
/**
 * Edit filter.gpu to ensure that only
 * X number of gpu filers can coexist.
 * @param {Array<Object>} filters
 * @returns {Array<Object>} updated filters
 */


function resetFilterGpuMode(filters) {
  var gpuPerDataset = {};
  return filters.map(function (f, i) {
    if (f.gpu) {
      var gpu = true;
      (0, _utils.toArray)(f.dataId).forEach(function (dataId) {
        var count = gpuPerDataset[dataId];

        if (count === _defaultSettings.MAX_GPU_FILTERS) {
          gpu = false;
        } else {
          gpuPerDataset[dataId] = count ? count + 1 : 1;
        }
      });

      if (!gpu) {
        return (0, _utils.set)(['gpu'], false, f);
      }
    }

    return f;
  });
}
/**
 * Initial filter uniform
 * @returns {Array<Array<Number>>}
 */


function getEmptyFilterRange() {
  return new Array(_defaultSettings.MAX_GPU_FILTERS).fill(0).map(function (d) {
    return [0, 0];
  });
} // By default filterValueAccessor expect each datum to be formated as {index, data}
// data is the row in allData, and index is its index in allData


var defaultGetIndex = function defaultGetIndex(d) {
  return d.index;
};

var defaultGetData = function defaultGetData(d) {
  return d.data;
};
/**
 *
 * @param {Array<Object>} channels
 * @return {Function} getFilterValue
 */


var getFilterValueAccessor = function getFilterValueAccessor(channels, dataId, fields) {
  return function () {
    var getIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultGetIndex;
    var getData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetData;
    return function (d) {
      return (// for empty channel, value is 0 and min max would be [0, 0]
        channels.map(function (filter) {
          if (!filter) {
            return 0;
          }

          var fieldIndex = getDatasetFieldIndexForFilter(dataId, filter);
          var field = fields[fieldIndex];
          var value = filter.type === _defaultSettings.FILTER_TYPES.timeRange ? field.filterProps && Array.isArray(field.filterProps.mappedValue) ? field.filterProps.mappedValue[getIndex(d)] : _moment["default"].utc(getData(d)[fieldIndex]).valueOf() : getData(d)[fieldIndex];
          return (0, _dataUtils.notNullorUndefined)(value) ? value - filter.domain[0] : Number.MIN_SAFE_INTEGER;
        })
      );
    };
  };
};
/**
 * Get filter properties for gpu filtering
 * @param {Array<Object>} filters
 * @param {string} dataId
 * @returns {{filterRange: {Object}, filterValueUpdateTriggers: Object, getFilterValue: Function}}
 */


function getGpuFilterProps(filters, dataId, fields) {
  var filterRange = getEmptyFilterRange();
  var triggers = {}; // array of filter for each channel, undefined, if no filter is assigned to that channel

  var channels = [];

  var _loop = function _loop(i) {
    var filter = filters.find(function (f) {
      return f.gpu && f.dataId.includes(dataId) && f.gpuChannel[f.dataId.indexOf(dataId)] === i;
    });
    filterRange[i][0] = filter ? filter.value[0] - filter.domain[0] : 0;
    filterRange[i][1] = filter ? filter.value[1] - filter.domain[0] : 0;
    triggers["gpuFilter_".concat(i)] = filter ? filter.name[filter.dataId.indexOf(dataId)] : null;
    channels.push(filter);
  };

  for (var i = 0; i < _defaultSettings.MAX_GPU_FILTERS; i++) {
    _loop(i);
  }

  var filterValueAccessor = getFilterValueAccessor(channels, dataId, fields);
  return {
    filterRange: filterRange,
    filterValueUpdateTriggers: triggers,
    filterValueAccessor: filterValueAccessor
  };
}
/**
 * Return dataset field index from filter.fieldIdx
 * The index matches the same dataset index for filter.dataId
 * @param dataset
 * @param filter
 * @return {*}
 */


function getDatasetFieldIndexForFilter(dataId, filter) {
  var datasetIndex = (0, _utils.toArray)(filter.dataId).indexOf(dataId);

  if (datasetIndex < 0) {
    return -1;
  }

  var fieldIndex = filter.fieldIdx[datasetIndex];
  return (0, _dataUtils.notNullorUndefined)(fieldIndex) ? fieldIndex : -1;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9ncHUtZmlsdGVyLXV0aWxzLmpzIl0sIm5hbWVzIjpbInNldEZpbHRlckdwdU1vZGUiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwiZGF0YUlkIiwiZm9yRWFjaCIsImRhdGFzZXRJZHgiLCJncHVGaWx0ZXJzIiwiZiIsImluY2x1ZGVzIiwiZ3B1IiwibGVuZ3RoIiwiTUFYX0dQVV9GSUxURVJTIiwiYXNzaWduR3B1Q2hhbm5lbHMiLCJhbGxGaWx0ZXJzIiwicmVkdWNlIiwiYWNjdSIsImluZGV4IiwiYXNzaWduR3B1Q2hhbm5lbCIsImdwdUNoYW5uZWwiLCJmaW5kR3B1Q2hhbm5lbCIsImNoYW5uZWwiLCJkYXRhSWR4IiwiaW5kZXhPZiIsImlkIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaW5kIiwiaSIsImV2ZXJ5IiwicmVzZXRGaWx0ZXJHcHVNb2RlIiwiZ3B1UGVyRGF0YXNldCIsIm1hcCIsImNvdW50IiwiZ2V0RW1wdHlGaWx0ZXJSYW5nZSIsIkFycmF5IiwiZmlsbCIsImQiLCJkZWZhdWx0R2V0SW5kZXgiLCJkZWZhdWx0R2V0RGF0YSIsImRhdGEiLCJnZXRGaWx0ZXJWYWx1ZUFjY2Vzc29yIiwiY2hhbm5lbHMiLCJmaWVsZHMiLCJnZXRJbmRleCIsImdldERhdGEiLCJmaWVsZEluZGV4IiwiZ2V0RGF0YXNldEZpZWxkSW5kZXhGb3JGaWx0ZXIiLCJmaWVsZCIsInZhbHVlIiwidHlwZSIsIkZJTFRFUl9UWVBFUyIsInRpbWVSYW5nZSIsImZpbHRlclByb3BzIiwiaXNBcnJheSIsIm1hcHBlZFZhbHVlIiwibW9tZW50IiwidXRjIiwidmFsdWVPZiIsImRvbWFpbiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJnZXRHcHVGaWx0ZXJQcm9wcyIsImZpbHRlclJhbmdlIiwidHJpZ2dlcnMiLCJuYW1lIiwicHVzaCIsImZpbHRlclZhbHVlQWNjZXNzb3IiLCJmaWx0ZXJWYWx1ZVVwZGF0ZVRyaWdnZXJzIiwiZGF0YXNldEluZGV4IiwiZmllbGRJ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R0FBRzVDLE1BQU0sQ0FBQ21FLFFBQVAsQ0FBZ0JELFlBQWhCLENBQW5CO0FBRUEsU0FBTyxtQ0FBbUJ0QixVQUFuQixJQUFpQ0EsVUFBakMsR0FBOEMsQ0FBQyxDQUF0RDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDIwIFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtzZXQsIHRvQXJyYXl9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQge01BWF9HUFVfRklMVEVSUywgRklMVEVSX1RZUEVTfSBmcm9tICdjb25zdGFudHMvZGVmYXVsdC1zZXR0aW5ncyc7XHJcbmltcG9ydCB7bm90TnVsbG9yVW5kZWZpbmVkfSBmcm9tICcuL2RhdGEtdXRpbHMnO1xyXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XHJcblxyXG4vKipcclxuICogU2V0IGdwdSBtb2RlIGJhc2VkIG9uIGN1cnJlbnQgbnVtYmVyIG9mIGdwdSBmaWx0ZXJzIGV4aXN0c1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZ3B1RmlsdGVyXHJcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmlsdGVyc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlckdwdU1vZGUoZmlsdGVyLCBmaWx0ZXJzKSB7XHJcbiAgLy8gZmlsdGVyIGNhbiBiZSBhcHBseSB0byBtdWx0aXBsZSBkYXRhc2V0LCBoZW5jZSBncHUgZmlsdGVyIG1vZGUgc2hvdWxkIGFsc28gYmVcclxuICAvLyBhbiBhcnJheSwgaG93ZXZlciwgdG8ga2VlcCB1cyBzYW5lLCBmb3Igbm93LCB3ZSBvbmx5IGNoZWNrIGlmIHRoZXJlIGlzIGF2YWlsYWJsZSBjaGFubmVsIGZvciBldmVyeSBkYXRhSWQsXHJcbiAgLy8gaWYgYWxsIG9mIHRoZW0gaGFzLCB3ZSBzZXQgZ3B1IG1vZGUgdG8gdHJ1ZVxyXG4gIC8vIFRPRE86IHJlZmFjdG9yIGZpbHRlciBzbyB3ZSBkb24ndCBrZWVwIGFuIGFycmF5IG9mIGV2ZXJ5dGhpbmdcclxuXHJcbiAgZmlsdGVyLmRhdGFJZC5mb3JFYWNoKChkYXRhSWQsIGRhdGFzZXRJZHgpID0+IHtcclxuICAgIGNvbnN0IGdwdUZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcihmID0+IGYuZGF0YUlkLmluY2x1ZGVzKGRhdGFJZCkgJiYgZi5ncHUpO1xyXG5cclxuICAgIGlmIChmaWx0ZXIuZ3B1ICYmIGdwdUZpbHRlcnMubGVuZ3RoID09PSBNQVhfR1BVX0ZJTFRFUlMpIHtcclxuICAgICAgcmV0dXJuIHNldChbJ2dwdSddLCBmYWxzZSwgZmlsdGVyKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGZpbHRlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkdwdUNoYW5uZWxzKGFsbEZpbHRlcnMpIHtcclxuICByZXR1cm4gYWxsRmlsdGVycy5yZWR1Y2UoKGFjY3UsIGYsIGluZGV4KSA9PiB7XHJcbiAgICBsZXQgZmlsdGVycyA9IGFjY3U7XHJcblxyXG4gICAgLy8gaWYgZ3B1IGlzIHRydWUgYXNzaWduIGFuZCB2YWxpZGF0ZSBncHUgQ2hhbm5lbFxyXG4gICAgaWYgKGYuZ3B1KSB7XHJcbiAgICAgIGYgPSBhc3NpZ25HcHVDaGFubmVsKGYsIGFjY3UpO1xyXG4gICAgICBmaWx0ZXJzID0gc2V0KFtpbmRleF0sIGYsIGFjY3UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaWx0ZXJzO1xyXG4gIH0sIGFsbEZpbHRlcnMpO1xyXG59XHJcbi8qKlxyXG4gKiBBc3NpZ24gYSBuZXcgZ3B1IGZpbHRlciBhIGNoYW5uZWwgYmFzZWQgb24gZmlyc3QgYXZhaWxhYmlsaXR5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcclxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBmaWx0ZXJzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduR3B1Q2hhbm5lbChmaWx0ZXIsIGZpbHRlcnMpIHtcclxuICAvLyBmaW5kIGZpcnN0IGF2YWlsYWJsZSBjaGFubmVsXHJcbiAgaWYgKCFmaWx0ZXIuZ3B1KSB7XHJcbiAgICByZXR1cm4gZmlsdGVyO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZ3B1Q2hhbm5lbCA9IGZpbHRlci5ncHVDaGFubmVsIHx8IFtdO1xyXG5cclxuICBmaWx0ZXIuZGF0YUlkLmZvckVhY2goKGRhdGFJZCwgZGF0YXNldElkeCkgPT4ge1xyXG4gICAgY29uc3QgZmluZEdwdUNoYW5uZWwgPSBjaGFubmVsID0+IGYgPT4ge1xyXG4gICAgICBjb25zdCBkYXRhSWR4ID0gdG9BcnJheShmLmRhdGFJZCkuaW5kZXhPZihkYXRhSWQpO1xyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgIGYuaWQgIT09IGZpbHRlci5pZCAmJiBkYXRhSWR4ID4gLTEgJiYgZi5ncHUgJiYgdG9BcnJheShmLmdwdUNoYW5uZWwpW2RhdGFJZHhdID09PSBjaGFubmVsXHJcbiAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChcclxuICAgICAgTnVtYmVyLmlzRmluaXRlKGdwdUNoYW5uZWxbZGF0YXNldElkeF0pICYmXHJcbiAgICAgICFmaWx0ZXJzLmZpbmQoZmluZEdwdUNoYW5uZWwoZ3B1Q2hhbm5lbFtkYXRhc2V0SWR4XSkpXHJcbiAgICApIHtcclxuICAgICAgLy8gaWYgdmFsdWUgaXMgYWxyZWFkeSBhc3NpZ25lZCBhbmQgdmFsaWRcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IE1BWF9HUFVfRklMVEVSUykge1xyXG4gICAgICBpZiAoIWZpbHRlcnMuZmluZChmaW5kR3B1Q2hhbm5lbChpKSkpIHtcclxuICAgICAgICBncHVDaGFubmVsW2RhdGFzZXRJZHhdID0gaTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBpZiBjYW5ub3QgZmluZCBjaGFubmVsIGZvciBhbGwgZGF0YWlkLCBzZXQgZ3B1IGJhY2sgdG8gZmFsc2VcclxuICAvLyBUT0RPOiByZWZhY3RvciBmaWx0ZXIgdG8gaGFuZGxlIHNhbWUgZmlsdGVyIGRpZmZlcmVudCBncHUgbW9kZVxyXG4gIGlmICghZ3B1Q2hhbm5lbC5sZW5ndGggfHwgIWdwdUNoYW5uZWwuZXZlcnkoTnVtYmVyLmlzRmluaXRlKSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uZmlsdGVyLFxyXG4gICAgICBncHU6IGZhbHNlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLmZpbHRlcixcclxuICAgIGdwdUNoYW5uZWxcclxuICB9O1xyXG59XHJcbi8qKlxyXG4gKiBFZGl0IGZpbHRlci5ncHUgdG8gZW5zdXJlIHRoYXQgb25seVxyXG4gKiBYIG51bWJlciBvZiBncHUgZmlsZXJzIGNhbiBjb2V4aXN0LlxyXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGZpbHRlcnNcclxuICogQHJldHVybnMge0FycmF5PE9iamVjdD59IHVwZGF0ZWQgZmlsdGVyc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RmlsdGVyR3B1TW9kZShmaWx0ZXJzKSB7XHJcbiAgY29uc3QgZ3B1UGVyRGF0YXNldCA9IHt9O1xyXG5cclxuICByZXR1cm4gZmlsdGVycy5tYXAoKGYsIGkpID0+IHtcclxuICAgIGlmIChmLmdwdSkge1xyXG4gICAgICBsZXQgZ3B1ID0gdHJ1ZTtcclxuICAgICAgdG9BcnJheShmLmRhdGFJZCkuZm9yRWFjaChkYXRhSWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gZ3B1UGVyRGF0YXNldFtkYXRhSWRdO1xyXG5cclxuICAgICAgICBpZiAoY291bnQgPT09IE1BWF9HUFVfRklMVEVSUykge1xyXG4gICAgICAgICAgZ3B1ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGdwdVBlckRhdGFzZXRbZGF0YUlkXSA9IGNvdW50ID8gY291bnQgKyAxIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFncHUpIHtcclxuICAgICAgICByZXR1cm4gc2V0KFsnZ3B1J10sIGZhbHNlLCBmKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbCBmaWx0ZXIgdW5pZm9ybVxyXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8TnVtYmVyPj59XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRFbXB0eUZpbHRlclJhbmdlKCkge1xyXG4gIHJldHVybiBuZXcgQXJyYXkoTUFYX0dQVV9GSUxURVJTKS5maWxsKDApLm1hcChkID0+IFswLCAwXSk7XHJcbn1cclxuXHJcbi8vIEJ5IGRlZmF1bHQgZmlsdGVyVmFsdWVBY2Nlc3NvciBleHBlY3QgZWFjaCBkYXR1bSB0byBiZSBmb3JtYXRlZCBhcyB7aW5kZXgsIGRhdGF9XHJcbi8vIGRhdGEgaXMgdGhlIHJvdyBpbiBhbGxEYXRhLCBhbmQgaW5kZXggaXMgaXRzIGluZGV4IGluIGFsbERhdGFcclxuY29uc3QgZGVmYXVsdEdldEluZGV4ID0gZCA9PiBkLmluZGV4O1xyXG5jb25zdCBkZWZhdWx0R2V0RGF0YSA9IGQgPT4gZC5kYXRhO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2hhbm5lbHNcclxuICogQHJldHVybiB7RnVuY3Rpb259IGdldEZpbHRlclZhbHVlXHJcbiAqL1xyXG5jb25zdCBnZXRGaWx0ZXJWYWx1ZUFjY2Vzc29yID0gKGNoYW5uZWxzLCBkYXRhSWQsIGZpZWxkcykgPT4gKFxyXG4gIGdldEluZGV4ID0gZGVmYXVsdEdldEluZGV4LFxyXG4gIGdldERhdGEgPSBkZWZhdWx0R2V0RGF0YVxyXG4pID0+IGQgPT5cclxuICAvLyBmb3IgZW1wdHkgY2hhbm5lbCwgdmFsdWUgaXMgMCBhbmQgbWluIG1heCB3b3VsZCBiZSBbMCwgMF1cclxuICBjaGFubmVscy5tYXAoZmlsdGVyID0+IHtcclxuICAgIGlmICghZmlsdGVyKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZmllbGRJbmRleCA9IGdldERhdGFzZXRGaWVsZEluZGV4Rm9yRmlsdGVyKGRhdGFJZCwgZmlsdGVyKTtcclxuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ZpZWxkSW5kZXhdO1xyXG5cclxuICAgIGNvbnN0IHZhbHVlID1cclxuICAgICAgZmlsdGVyLnR5cGUgPT09IEZJTFRFUl9UWVBFUy50aW1lUmFuZ2VcclxuICAgICAgICA/IGZpZWxkLmZpbHRlclByb3BzICYmIEFycmF5LmlzQXJyYXkoZmllbGQuZmlsdGVyUHJvcHMubWFwcGVkVmFsdWUpXHJcbiAgICAgICAgICA/IGZpZWxkLmZpbHRlclByb3BzLm1hcHBlZFZhbHVlW2dldEluZGV4KGQpXVxyXG4gICAgICAgICAgOiBtb21lbnQudXRjKGdldERhdGEoZClbZmllbGRJbmRleF0pLnZhbHVlT2YoKVxyXG4gICAgICAgIDogZ2V0RGF0YShkKVtmaWVsZEluZGV4XTtcclxuXHJcbiAgICByZXR1cm4gbm90TnVsbG9yVW5kZWZpbmVkKHZhbHVlKSA/IHZhbHVlIC0gZmlsdGVyLmRvbWFpblswXSA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xyXG4gIH0pO1xyXG5cclxuLyoqXHJcbiAqIEdldCBmaWx0ZXIgcHJvcGVydGllcyBmb3IgZ3B1IGZpbHRlcmluZ1xyXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGZpbHRlcnNcclxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFJZFxyXG4gKiBAcmV0dXJucyB7e2ZpbHRlclJhbmdlOiB7T2JqZWN0fSwgZmlsdGVyVmFsdWVVcGRhdGVUcmlnZ2VyczogT2JqZWN0LCBnZXRGaWx0ZXJWYWx1ZTogRnVuY3Rpb259fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEdwdUZpbHRlclByb3BzKGZpbHRlcnMsIGRhdGFJZCwgZmllbGRzKSB7XHJcbiAgY29uc3QgZmlsdGVyUmFuZ2UgPSBnZXRFbXB0eUZpbHRlclJhbmdlKCk7XHJcbiAgY29uc3QgdHJpZ2dlcnMgPSB7fTtcclxuXHJcbiAgLy8gYXJyYXkgb2YgZmlsdGVyIGZvciBlYWNoIGNoYW5uZWwsIHVuZGVmaW5lZCwgaWYgbm8gZmlsdGVyIGlzIGFzc2lnbmVkIHRvIHRoYXQgY2hhbm5lbFxyXG4gIGNvbnN0IGNoYW5uZWxzID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0dQVV9GSUxURVJTOyBpKyspIHtcclxuICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlcnMuZmluZChcclxuICAgICAgZiA9PiBmLmdwdSAmJiBmLmRhdGFJZC5pbmNsdWRlcyhkYXRhSWQpICYmIGYuZ3B1Q2hhbm5lbFtmLmRhdGFJZC5pbmRleE9mKGRhdGFJZCldID09PSBpXHJcbiAgICApO1xyXG5cclxuICAgIGZpbHRlclJhbmdlW2ldWzBdID0gZmlsdGVyID8gZmlsdGVyLnZhbHVlWzBdIC0gZmlsdGVyLmRvbWFpblswXSA6IDA7XHJcbiAgICBmaWx0ZXJSYW5nZVtpXVsxXSA9IGZpbHRlciA/IGZpbHRlci52YWx1ZVsxXSAtIGZpbHRlci5kb21haW5bMF0gOiAwO1xyXG5cclxuICAgIHRyaWdnZXJzW2BncHVGaWx0ZXJfJHtpfWBdID0gZmlsdGVyID8gZmlsdGVyLm5hbWVbZmlsdGVyLmRhdGFJZC5pbmRleE9mKGRhdGFJZCldIDogbnVsbDtcclxuICAgIGNoYW5uZWxzLnB1c2goZmlsdGVyKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZpbHRlclZhbHVlQWNjZXNzb3IgPSBnZXRGaWx0ZXJWYWx1ZUFjY2Vzc29yKGNoYW5uZWxzLCBkYXRhSWQsIGZpZWxkcyk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmaWx0ZXJSYW5nZSxcclxuICAgIGZpbHRlclZhbHVlVXBkYXRlVHJpZ2dlcnM6IHRyaWdnZXJzLFxyXG4gICAgZmlsdGVyVmFsdWVBY2Nlc3NvclxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gZGF0YXNldCBmaWVsZCBpbmRleCBmcm9tIGZpbHRlci5maWVsZElkeFxyXG4gKiBUaGUgaW5kZXggbWF0Y2hlcyB0aGUgc2FtZSBkYXRhc2V0IGluZGV4IGZvciBmaWx0ZXIuZGF0YUlkXHJcbiAqIEBwYXJhbSBkYXRhc2V0XHJcbiAqIEBwYXJhbSBmaWx0ZXJcclxuICogQHJldHVybiB7Kn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhc2V0RmllbGRJbmRleEZvckZpbHRlcihkYXRhSWQsIGZpbHRlcikge1xyXG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IHRvQXJyYXkoZmlsdGVyLmRhdGFJZCkuaW5kZXhPZihkYXRhSWQpO1xyXG4gIGlmIChkYXRhc2V0SW5kZXggPCAwKSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaWVsZEluZGV4ID0gZmlsdGVyLmZpZWxkSWR4W2RhdGFzZXRJbmRleF07XHJcblxyXG4gIHJldHVybiBub3ROdWxsb3JVbmRlZmluZWQoZmllbGRJbmRleCkgPyBmaWVsZEluZGV4IDogLTE7XHJcbn1cclxuIl19